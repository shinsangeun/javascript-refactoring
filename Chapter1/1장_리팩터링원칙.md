### 1장. 리팩터링 원칙
---

#### [목차]
1. 리팩터링 정의
2. 리팩터링 하는 이유
3. 언제 리팩터링 해야 할까?
4. 리팩터링 시 고려할 문제
5. 리팩터링과 성능

-----

#### 1. 리팩터링 정의
- 리팩터링의 원칙에 대해 알아보기 앞서 리팩토링의 '사전적 정의'는 다음과 같습니다.
  - [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경 하는 기법
  - [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성 하다.

=> 두 개의 용어를 한문장에 담으면 “앞으로 몇시간은 리팩터링 할 것 같은데 그 사이 적용하는 리팩터링은 수십가지가 될것 같다.” 라고 할 수 있습니다.  
리팩터링 하는 동안에는 코드가 항상 정상작동 하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있습니다.  

> 누군가 “리팩터링 하다가 코드가 깨져서 며칠이나 고생했다＂ 라고 한다면, 십중팔구 리팩터링 한것이 아니다.  

  

#### 2. 두 개의 모자
- 전체 작업 시간이 10분 정도로 짧다고 해도, 항상 내가 쓰고 있는 모자가 어떤 것인지 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 합니다.
  - 기능 추가
    - 기능을 추가 할 때는‘기능 추가’ 모자를 쓰고 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다. 
    
  - 리팩터링
    - 리팩터링 할 때는‘리팩터링’ 모자를 쓰고 기능추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념 한다. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.


 
#### 3. 리팩터링 하는 이유
##### 3-1. 소프트웨어 설계가 좋아진다
 * 단기 목표만을 위해 코드를 수정하면 기반 구조가 쉽게 무너짐
 * 중복 코드를 제거하는 설계는 바람직한 설계의 핵심임


#####  3-2. 소프트웨어를 이해하기 쉬워진다
 * 내 코드는 나만 사용하는 것이 아니기 때문에 다른 사람과 나를 배려하기 위해 리팩터링이 필요함
 * 코드가 더 잘 읽히게 도와줌


##### 3-3. 버그를 쉽게 찾을 수 있다
 * 코드를 이해하기 쉽다 = 버그를 찾기 쉽다
 * 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 되기 때문이다
 
 
##### 3-4. 프로그래밍 속도를 높일 수 있다
 * 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질 까봐 걱정 할 수 있지만 리팩터링으로 인해 프로그래밍 속도를 높일 수 있음
 * 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는데 드는 시간이 늘어난다


##### 3-5. 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.


##### 3-6. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.


##### 3-7. 코드가 명확하면 버그를 만들 가능성도 줄고, 디버깅 하기도 쉽다. 내부 품질이 뛰어는 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.


##### 3-8. 예전엔 설계를 잘 하려면 코딩을 시작하기 전에 설계부터 완벽히 마쳐야 한다는 것이 정설이었지만,이제는 리팩터링을 통해 기존 코드의 설계를 얼마든지 개선할 수 있으므로 설령 프로그램의 요구사항이 바뀌더라도 설계를 지속해서 개선 할 수 있다.



#### 4. 언제 리팩터링 해야할까?
##### 4-1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
 * 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 
 * 함수를 복제해서 조금만 수정 해도 되지만, 그러면 중복 코드가 발생하고 어디 있는지 일일이 찾아야 한다. 버그를 잡을 때도 마찬가지로 중복 코드가 있으면 버그가 여러군데에서 나타날 수 있다.
 * 이럴 때는 ‘함수 매개변수화하기’의 리팩터링 방법을 적용한다.


##### 4-2. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
 * 코드를 수정 하기 전에 먼저 그 코드가 하는 일을 파악한다.
 * 조건부 로직의 구조가 이상하지 않은지 살펴보거나 함수 이름이 이상하지 않는지 확인한다.


##### 4-3. 쓰레기 줍기 리팩터링
 * 코드를 파악하던 중에 일을 비효율 적으로 처리하는 모습을 발견하게 될 때가 있다. 
 * 로직이 쓸데없이 복잡하거나, 매개변수화한 하수가 하나면 될 일을 거의 똑같은 함수 여러개로 작성해놨을 수 있다. 


##### 4-4. 계획된 리팩터링 & 수시로 하는 리팩터링
 * 보기 싫은 코드를 발견하면 리팩터링하자. 
 * 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.


##### 4-5. 오래 걸리는 리팩터링
* 리팩터링은 대부분 몇 분 안에 끝난다. 하지만 팀 전체가 달려들어도 몇주가 걸리는 대규모 리팩터링이 있다. 
* 팀 전체가 리팩터링 하기 보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적 일 때가 많다.


##### 4-6. 코드 리뷰에 리팩터링 활용하기
* 코드 리뷰는 개발 팀 전체에 지식을 전파하는 데 좋다. 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다. 
* 코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.


##### 4-7. 리팩터링 하지 말아야 할 때
* 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링 하지 않는다.
* 리팩터링하는것 보다 처음부터 새로 작성하는게 쉬울 때도 리팩터링 하지 않는다.



#### 5. 리팩터링 시 고려할 문제
##### 5-1. 새 기능 개발 속도 저하
* 리팩터링의 궁극적인 목표는 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출 하는 것이다.


##### 5-2. 코드 소유권
* 코드 소유권을 개인 단위로 나눌지 팀 단위로 나눠서 관리할지 고려 해야 한다.
* 브랜치를 따서 수정하고 커밋을 요청하는 방식은 대규모 시스템 개발시 어울린다.


##### 5-3. 브랜치
* 기능이 추가 될 때마다 버전을 명확히 나눌 수 있고, 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있다.
* 개발 기간이 길어질 수록 마스터 브랜치와 머지하기 복잡한 단점이 있다.


##### 5-4. 테스팅
* 리팩터링의 특성은 동작은 똑같이 유지되면서, 절차를 지켜 제대로 하면 동작이 깨지지 않아야 한다.
* 자가 테스트 코드로 안전하게 테스트 해야 한다.


##### 5-5. 레거시 코드
* 물려받은 레거시 코드는 대체로 복잡하고 제대로 갖춰지지 않은 것들이 많다.
* 테스트 보강을 통해 레거시 코드를 파악하고 리팩터링 해야 한다.


##### 5-6. 데이터베이스
* 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다. 
* 데이터베이스를 변경하는 일은 병렬 수정(또는 팽창-수축)의 일반적인 예.


#### 6. 리팩터링과 성능
##### 6-1. 끊임없이 관심을 기울이는 것
* 프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다. 
* 성능을 개선하기 위한 최적화 프로그램이 퍼지게 되지만 정작 동작을 제대로 이해하지 못한 채 작성할 때도 많다.


##### 6-2. 시간 예산 분배 방식
* 설계를 여러 컴포넌트로 나눠서 자원 예산을 할당한다. 할당된 자원 예산을 초과 할 수 없고, 엄격한 시간 엄수를 강조한다.


##### 6-3. 90%의 시간은 낭비
* 의도적으로 성능 최적화에 돌입하기전까지는 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.


##### 6-4. 성능 튜닝에 투입할 시간을 벌 수 있다.
* 리팩터링이 잘 되어 있다면 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있다.


##### 6-5. 성능을 더 세밀하게 분석 할 수 있다.
* 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 튜닝하기 쉬워진다. 
* 코드가 깔끔하면 개선안들이 더 잘 떠오를 것이고, 그중  어떤 튜닝이 효과가 좋을지 파악하기 쉽다.




